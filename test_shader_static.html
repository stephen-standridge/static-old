<html>
    <head><link rel="stylesheet" href="css/main.css">
    </head>
    <body>

        <div id="container"></div>
        <script src="js/three.min.js"></script>
        <script id="vertexShader" type="x-shader/x-vertex">
            void main() {
                gl_Position = vec4( position, 1.0 );
            }
        </script>
        <script id="fragmentShader" type="x-shader/x-fragment">
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_time;

            float plot(vec2 st, float pct){
                return smoothstep( pct-0.02, pct, st.y) -
                        smoothstep( pct, pct+0.02, st.y );
            }
            float booleanToPosOrNeg(bool determiner){
                if(determiner == true){
                    return 1.0;
                } else{
                    return -1.0;
                }
            }
            float rand(vec2 co){
              return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }
            void main() {
                vec2 st = gl_FragCoord.xy/u_resolution;
                float PI = 3.1415926535;
                float duration = 2000.0;
                float freq = 2.0;
                vec2 movement = vec2(1.5,1.5);
                vec2 power = vec2(1.5, 1.5);
                vec2 offset = vec2(23.0, -2.5);
                vec2 lineOffset = vec2(30.0, 60.0);
                vec2 linePower = vec2(2.0, 3.0);
                vec2 step = vec2(400.0,300.0);
                float row = st.y / step.y;
                float column = st.x /step.x;
                float rowPosOrNeg = booleanToPosOrNeg(bool(floor(mod((st.x*step.x), 2.0))));



                float horizontalVariation = pow(cos(u_time + ((st.x / 2.0) + lineOffset.x)), linePower.x);
                float verticalVariation = pow(cos(u_time + ((st.y / 2.0) + lineOffset.y)), linePower.y);
                float horizontalMovement = pow(sin((u_time / duration)* offset.x ) * horizontalVariation * freq, movement.x);
                float verticalMovement = pow(sin((u_time / duration)* offset.y) * verticalVariation *freq, movement.y);
                float verticalTracking = cos(u_time/duration / row * offset.y /(rand(vec2(u_time/duration - row, u_time/duration + row))));
                float horizontalTracking = (cos( u_time / duration * column)* offset.x ) * 2.0;
                float horizontalTest = float(mod((st.x*step.x)+(rowPosOrNeg * horizontalMovement)+horizontalTracking , 2.0));
                float verticalTest = float(mod( (st.y * step.y)+(rowPosOrNeg * verticalMovement) + verticalTracking, 2.0 ));

                bool p = bool((horizontalTest > float(1.0) &&
                                horizontalTest >  float(-1.0) &&
                                horizontalTest < float(0.0)) ||
                                !(horizontalTest > float(1.0) ||
                                horizontalTest >  float(-1.0) &&
                                horizontalTest < float(0.0)));
                bool q = bool(verticalTest < float(1.0) &&
                                verticalTest > float(0.0) &&
                                verticalTest < float(-1.0)) ||
                                !(verticalTest < float(1.0) &&
                                verticalTest > float(0.0) ||
                                verticalTest < float(-1.0));
                vec3 finalValue = vec3(float((p && q) || !(p || q) ) * rand(vec2(-1.0,2.0)));


                vec4 color = vec4(vec3(finalValue), 0.5);
                vec4 finalColor = vec4(color * vec4(0.2,0.7,0.2,0.2));

                // float pct = plot(st, y);
                // color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);

                gl_FragColor = finalColor;
            }
        </script>
        <script>
            // if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            var container;
            var camera, scene, renderer;
            var uniforms;

            init();
            animate();

            function init() {
                container = document.getElementById( 'container' );

                camera = new THREE.Camera();
                camera.position.z = 1;

                scene = new THREE.Scene();

                var geometry = new THREE.PlaneBufferGeometry( 2, 2 );

                uniforms = {
                    u_time: { type: "f", value: 1.0 },
                    u_resolution: { type: "v2", value: new THREE.Vector2() }
                };

                var material = new THREE.ShaderMaterial( {
                    uniforms: uniforms,
                    vertexShader: document.getElementById( 'vertexShader' ).textContent,
                    fragmentShader: document.getElementById( 'fragmentShader' ).textContent
                } );

                var mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );

                container.appendChild( renderer.domElement );

                onWindowResize();
                window.addEventListener( 'resize', onWindowResize, false );
            }

            function onWindowResize( event ) {
                renderer.setSize( window.innerWidth, window.innerHeight );
                uniforms.u_resolution.value.x = renderer.domElement.width;
                uniforms.u_resolution.value.y = renderer.domElement.height;
            }

            function animate() {
                requestAnimationFrame( animate );
                render();
            }

            function render() {
                uniforms.u_time.value += 0.05;
                renderer.render( scene, camera );
            }
        </script>
    </body>
</html>