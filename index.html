<!DOCTYPE html>
<html>
  <head>

  </head>
  <body>
  </body>
  <script src="js/three.js"></script>
  <script src="js/objectLoader.js"></script>
  <script src="js/orbitControls.js"></script>
  <script src="js/helpers.js"></script>
  <script src="js/camerasController.js"></script>
  <script src="js/lightsController.js"></script>
  <script src="js/materialsController.js"></script>
  <script id="static-vert" type="x-shader/x-fragment">
    uniform mat4 model_view_projection_matrix;
    void main() {
      gl_Position = projectionMatrix *
                modelViewMatrix *
                vec4(position,1.0);
    }
  </script>
  <script id="static-frag" type="x-shader/x-fragment">
      uniform vec2 u_resolution;
      uniform vec2 u_mouse;
      uniform float u_time;

      float booleanToPosOrNeg(bool determiner){
          if(determiner == true){
              return 1.0;
          } else{
              return -1.0;
          }
      }
      float rand(vec2 co){
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }
      vec3 randomDistributedColor(float s1, float s2){
          float randSeed1;
          float randSeed2;        
          randSeed1 = rand(u_time * vec2(s1, s2) + u_time);
          randSeed2 = rand(u_time / vec2(s2, s1) + u_time);
          return vec3(rand(vec2(randSeed1, randSeed2)));        
      }
      float displace( float grain, float resolution, float power, float rand){
        float loop = mod( u_time, ( rand ) );
        return pow( sin( loop + grain / resolution ), power );
      }
      float upToDownDiscolor(float offset, float power, float pos, float rand){
        float loop = mod( u_time, ( 5.0 * rand ) );        
        return pow( sin( u_time + pos + offset ), power);
      }
      void main() {
          vec2 st = gl_FragCoord.xy / u_resolution.xy;
          float horizontalTest;
          float verticalTest;
          float grainSize = 60.0;
          // float motionLoop = (u_time / 1.0) - floor(u_time/1.0);
          // float motionLoop2 = cos(u_time / 2.0);          
          vec2 tracking = vec2(21.3, 3.7);
          vec2 offset = vec2(20.0, 0.0);
          vec3 randomColor;
          vec3 finalColor;
          vec3 trackColor;
          vec3 movementColor1;
          vec3 movementColor2;
          float verticalDisplacement;
          float horizontalDisplacement;
          float rowOffset = sin(u_time / 5.0);
          float columnOffset = (u_time / 5.0) - floor(u_time/5.0);
          float rowOffset2 = sin(u_time / 5.0);
          float columnOffset2 = (u_time / 3.0) - floor(u_time/3.0);          
          float row1 = ceil(rowOffset +(st.x  * u_resolution.x) / grainSize);
          float column1 = ceil(columnOffset +(st.y * u_resolution.y) / grainSize);
          float row2 = ceil(rowOffset2 +(st.x  * u_resolution.x) / grainSize);
          float column2 = ceil(columnOffset2 +(st.y * u_resolution.y) / grainSize * 2.0);          
          
          float totalRows = u_resolution.x / grainSize;
          float totalColumns = u_resolution.y / grainSize;
          float randSeed1 = rand(u_time * vec2(st.x, st.y) + u_time);
          float randSeed2 = rand(u_time *  vec2(st.y, st.x) + u_time);

          horizontalDisplacement = ceil( st.x / displace( grainSize, u_resolution.x, tracking.x, randSeed2 ) );                
          verticalDisplacement = ceil( st.y / displace( grainSize, u_resolution.y, tracking.y, randSeed1 ) );   

          horizontalTest = ceil( st.x / (grainSize/ u_resolution.x) );   
          verticalTest = ceil( st.y / (grainSize/ u_resolution.y) );

          horizontalTest = horizontalTest * (horizontalDisplacement * 0.1);
          verticalTest = verticalTest * (verticalDisplacement * 0.1);

          randomColor = randomDistributedColor(horizontalTest, verticalTest);
          // trackColor = vec3( max ( min( randomColor / vec3( verticalTracking), 0.8 ), 0.2 ) );
          movementColor1 = vec3( ( (column1 / totalColumns) * (1.0 - 0.6)) + 0.6 );
          movementColor2 = vec3( ( (column2 / totalColumns) * (1.0 - 0.5)) + 0.5 );
          finalColor = movementColor1 * movementColor2 - (randomColor * 0.4 );
          // finalColor = vec3(randomColor * verticalTracking, randomColor * verticalTracking, randomColor * verticalTracking);
          /* return 1 if odd, 0 if even */
          // horizontalTest = mod ( horizontalTest, 2.0 );
          // verticalTest = mod ( verticalTest, 2.0 );

          gl_FragColor = vec4(finalColor, 1.0);
      }
  </script>

  <script src="js/main.js"></script>

</html>
